Since I have only seen the first 25 lines of your original file (the screenshot), I cannot reproduce your *exact* original code for lines 26-145.

However, I can provide you with a **complete, upgraded "Version 2.0"** of `bin/ci5` that includes:

1. Your original configuration and hardware checks.
2. **The Federation Logic** (multiple sources) we just discussed.
3. **The Authentication Logic** (Standard GitHub Device Flow).
4. **The Install Logic** (Parsing the JSON to find/run Corks).

You can overwrite your existing file with this. It implements everything we have built so far.

### `bin/ci5` (Federation Edition)

```bash
#!/bin/bash
# ‚õ©Ô∏è Ci5 CLI (v2.0-FEDERATION)
# The Bridge: Enables 'ci5 login' (Auth), 'ci5 run' (Install), and Registry Management.
# Privacy: Anonymous by default. Auth is strictly opt-in.

# --- CONFIGURATION ---
CLIENT_ID="Ov23lisWq6nuhqFog2xr"
AUTH_FILE="/etc/ci5/auth.token"
SOURCES_FILE="/etc/ci5/sources.list"
CACHE_FILE="/tmp/ci5_registry_composite.json"
OFFICIAL_REGISTRY="https://ci5.dev/corks.json"

# --- COLORS ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# --- HELPERS ---
ensure_dependencies() {
    if ! command -v jq >/dev/null; then
        echo "Installing dependencies (jq)..."
        # Detect OS for package manager
        if command -v opkg >/dev/null; then
            opkg update && opkg install jq >/dev/null
        elif command -v apt-get >/dev/null; then
            sudo apt-get update && sudo apt-get install -y jq >/dev/null
        else
            echo -e "${RED}Error: Could not install 'jq'. Please install manually.${NC}"
            exit 1
        fi
    fi
}

get_serial() {
    grep -i "serial" /proc/cpuinfo 2>/dev/null | awk '{print $3}' || cat /etc/ci5_hwid 2>/dev/null
}

init_sources() {
    if [ ! -d "/etc/ci5" ]; then
        # Handle permission issues if not root
        if [ "$EUID" -ne 0 ]; then
            sudo mkdir -p /etc/ci5
            sudo chown $USER /etc/ci5
        else
            mkdir -p /etc/ci5
        fi
    fi

    if [ ! -f "$SOURCES_FILE" ]; then
        echo "$OFFICIAL_REGISTRY" > "$SOURCES_FILE"
    fi
}

# --- REGISTRY FUNCTIONS (FEDERATION) ---
cmd_repo_add() {
    init_sources
    NEW_URL="$1"
    
    if [[ -z "$NEW_URL" ]]; then
        echo "Usage: ci5 repo add <url>"
        exit 1
    fi

    echo -n "Verifying source..."
    if ! curl --head --silent --fail "$NEW_URL" >/dev/null; then
        echo -e " ${RED}FAILED${NC}"
        echo "Error: URL is unreachable."
        exit 1
    fi

    echo "$NEW_URL" >> "$SOURCES_FILE"
    echo -e " ${GREEN}OK${NC}"
    echo "Added source: $NEW_URL"
    echo "Run 'ci5 update' to refresh."
}

update_registry() {
    init_sources
    echo "üîÑ Fetching Corks from sources..."
    
    # Initialize empty registry structure
    echo '{"official":{}, "community":{}}' > "$CACHE_FILE"

    while IFS= read -r URL || [ -n "$URL" ]; do
        # Skip comments/empty lines
        [[ "$URL" =~ ^#.*$ ]] || [[ -z "$URL" ]] && continue
        
        echo -n "   -> Pulling from $(basename $URL)..."
        FETCHED=$(curl -s --max-time 5 "$URL")
        
        if echo "$FETCHED" | jq empty >/dev/null 2>&1; then
            # Merge logic: deep merge, later sources override earlier ones
            jq -s '.[0] * .[1]' "$CACHE_FILE" <(echo "$FETCHED") > "${CACHE_FILE}.tmp" && mv "${CACHE_FILE}.tmp" "$CACHE_FILE"
            echo -e " ${GREEN}OK${NC}"
        else
            echo -e " ${YELLOW}SKIP (Invalid JSON)${NC}"
        fi
    done < "$SOURCES_FILE"
    
    COUNT=$(jq '.community | length + (.official | length)' "$CACHE_FILE")
    echo -e "${GREEN}‚úÖ Update complete. $COUNT Corks available.${NC}"
}

# --- AUTHENTICATION (DEVICE FLOW) ---
cmd_login() {
    echo "üîê Initiating Device Flow..."
    
    # 1. Request Code
    RESPONSE=$(curl -s -X POST -H "Accept: application/json" \
        -d "client_id=$CLIENT_ID" \
        -d "scope=read:user" \
        "https://github.com/login/device/code")
    
    DEVICE_CODE=$(echo $RESPONSE | jq -r .device_code)
    USER_CODE=$(echo $RESPONSE | jq -r .user_code)
    VERIFY_URL=$(echo $RESPONSE | jq -r .verification_uri)
    INTERVAL=$(echo $RESPONSE | jq -r .interval)

    if [ "$DEVICE_CODE" == "null" ]; then
        echo -e "${RED}Error contacting GitHub.${NC}"
        exit 1
    fi

    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  ACTION REQUIRED:${NC}"
    echo "1. Open: ${GREEN}$VERIFY_URL${NC}"
    echo "2. Code: ${GREEN}$USER_CODE${NC}"
    echo ""
    echo "Polling for authentication..."

    # 2. Poll for Token
    while true; do
        sleep $((INTERVAL + 1))
        TOKEN_RESP=$(curl -s -X POST -H "Accept: application/json" \
            -d "client_id=$CLIENT_ID" \
            -d "device_code=$DEVICE_CODE" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:device_code" \
            "https://github.com/login/oauth/access_token")
            
        ACCESS_TOKEN=$(echo $TOKEN_RESP | jq -r .access_token)
        ERROR=$(echo $TOKEN_RESP | jq -r .error)

        if [ "$ACCESS_TOKEN" != "null" ]; then
            mkdir -p $(dirname $AUTH_FILE)
            echo "$ACCESS_TOKEN" > "$AUTH_FILE"
            chmod 600 "$AUTH_FILE"
            echo -e "${GREEN}Success! Device Authenticated.${NC}"
            
            # Send Hardware Binding (Mockup of backend call)
            SERIAL=$(get_serial)
            # curl -X POST https://ci5.dev/api/bind -d "serial=$SERIAL" -H "Authorization: Bearer $ACCESS_TOKEN"
            echo "Hardware ID [$SERIAL] bound to identity."
            break
        fi

        if [ "$ERROR" == "access_denied" ] || [ "$ERROR" == "expired_token" ]; then
            echo -e "${RED}Auth failed: $ERROR${NC}"
            exit 1
        fi
    done
}

# --- INSTALLATION ---
cmd_run() {
    CORK_ID="$1"
    if [ -z "$CORK_ID" ]; then
        echo "Usage: ci5 run <cork_id>"
        exit 1
    fi

    if [ ! -f "$CACHE_FILE" ]; then
        update_registry
    fi

    # Lookup Cork in both Official and Community lists
    ENTRY=$(jq -r ".official[\"$CORK_ID\"] // .community[\"$CORK_ID\"]" "$CACHE_FILE")

    if [ "$ENTRY" == "null" ]; then
        echo -e "${RED}Cork '$CORK_ID' not found in registry.${NC}"
        echo "Try 'ci5 update' or check spelling."
        exit 1
    fi

    REPO=$(echo "$ENTRY" | jq -r .repo)
    RAM=$(echo "$ENTRY" | jq -r .ram)
    DESC=$(echo "$ENTRY" | jq -r .desc)

    echo -e "${GREEN}Found: $CORK_ID${NC}"
    echo "Desc: $DESC"
    echo "Repo: $REPO"
    echo "RAM:  $RAM"
    echo ""
    echo -n "Install this Cork? [y/N] "
    read -r CONFIRM
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
        echo "üöÄ Deploying..."
        
        # Deployment Logic (simplified)
        TARGET_DIR="/opt/ci5/corks/$CORK_ID"
        mkdir -p "$TARGET_DIR"
        
        # Clone or Pull
        if [ -d "$TARGET_DIR/.git" ]; then
            cd "$TARGET_DIR" && git pull
        else
            git clone "https://github.com/$REPO" "$TARGET_DIR"
        fi
        
        # Run
        cd "$TARGET_DIR"
        if [ -f "docker-compose.yml" ]; then
            if command -v docker >/dev/null; then
                docker compose up -d
                echo -e "${GREEN}Deployment Complete.${NC}"
            else
                echo -e "${RED}Error: Docker not found.${NC}"
            fi
        else
            echo "No docker-compose.yml found. Check repo instructions."
        fi
    else
        echo "Aborted."
    fi
}

# --- MAIN ENTRYPOINT ---
ensure_dependencies

case "$1" in
    login)
        cmd_login
        ;;
    repo)
        if [ "$2" == "add" ]; then
            cmd_repo_add "$3"
        else
            echo "Unknown command. Use: ci5 repo add <url>"
        fi
        ;;
    update)
        update_registry
        ;;
    run|install)
        cmd_run "$2"
        ;;
    *)
        echo "‚õ©Ô∏è  Ci5 CLI (v2.0)"
        echo "Usage:"
        echo "  ci5 login           - Authenticate device"
        echo "  ci5 update          - Refresh registry"
        echo "  ci5 run <cork>      - Install a Cork"
        echo "  ci5 repo add <url>  - Add 3rd party registry"
        ;;
esac

```